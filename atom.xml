<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lrving`s Blog</title>
  <icon>https://www.gravatar.com/avatar/9c2536db89f37a92e8b73c880ff0628e</icon>
  <subtitle>–- 要技艺超群，要予人温暖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lwju.xyz/"/>
  <updated>2019-11-11T13:50:33.408Z</updated>
  <id>http://lwju.xyz/</id>
  
  <author>
    <name>Lrving</name>
    <email>1018610468@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA笔记(七):面向对象基础(五)</title>
    <link href="http://lwju.xyz/Java/javanote7/"/>
    <id>http://lwju.xyz/Java/javanote7/</id>
    <published>2019-11-11T13:41:09.000Z</published>
    <updated>2019-11-11T13:50:33.408Z</updated>
    
    <content type="html"><![CDATA[<h6 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h6><p><strong>String</strong></p><p>在Java中，<code>String</code>是一个引用类型，它本身也是一个<code>class</code>。但是，Java编译器对<code>String</code>有特殊处理，即可以直接用<code>&quot;...&quot;</code>来表示一个字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Hello!"</span>;</span><br></pre></td></tr></table></figure><p>实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s2 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'!'</span>&#125;);</span><br></pre></td></tr></table></figure><p>因为<code>String</code>太常用了，所以Java提供了<code>&quot;...&quot;</code>这种字符串字面量表示方法。</p><a id="more"></a><p>Java字符串的一个重要特点就是字符串<code>不可变</code>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p><p><strong>字符串比较</strong><br>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用equals()方法而不能用==。</p><p> “==”代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。</p><p>Object类中定义有：public boolean equals(Object obj)方法，提供定义“对象内容相等”的逻辑。比如，我们在公安系统中认为id相同的人就是同一个人、学籍系统中认为学号相同的人就是同一个人。</p><p>Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。但是，我们可以根据我们自己的要求重写equals方法。</p><p>equals方法测试和自定义类重写equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEquals</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">123</span>,<span class="string">"郑工"</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">123</span>,<span class="string">"软件"</span>);     </span><br><span class="line">        System.out.println(p1==p2);     <span class="comment">//false，不是同一个对象</span></span><br><span class="line">        System.out.println(p1.equals(p2));  <span class="comment">//true，id相同则认为两个对象内容相同</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"软件技术"</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"软件技术);</span></span><br><span class="line"><span class="string">        System.out.println(s1==s2);         //false, 两个字符串不是同一个对象</span></span><br><span class="line"><span class="string">        System.out.println(s1.equals(s2));  //true,  两个字符串内容相同</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Person &#123;</span></span><br><span class="line"><span class="string">    int id;</span></span><br><span class="line"><span class="string">    String name;</span></span><br><span class="line"><span class="string">    public Person(int id,String name) &#123;</span></span><br><span class="line"><span class="string">        this.id=id;</span></span><br><span class="line"><span class="string">        this.name=name;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public boolean equals(Object obj) &#123;</span></span><br><span class="line"><span class="string">        if(obj == null)&#123;</span></span><br><span class="line"><span class="string">            return false;</span></span><br><span class="line"><span class="string">        &#125;else &#123;</span></span><br><span class="line"><span class="string">            if(obj instanceof Person) &#123;</span></span><br><span class="line"><span class="string">                Person c = (Person)obj;</span></span><br><span class="line"><span class="string">                if(c.id==this.id) &#123;</span></span><br><span class="line"><span class="string">                    return true;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return false;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>结论：两个字符串比较，必须总是使用<code>equals()</code>方法。<br>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p><p><strong>替换子串</strong></p><p>要在字符串中替换子串,根据字符或字符串替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line">s.replace(<span class="string">'l'</span>, <span class="string">'w'</span>); <span class="comment">// "hewwo"，所有字符'l'被替换为'w'</span></span><br><span class="line">s.replace(<span class="string">"ll"</span>, <span class="string">"~~"</span>); <span class="comment">// "he~~o"，所有子串"ll"被替换为"~~"</span></span><br></pre></td></tr></table></figure><p><strong>分割字符串</strong><br>要分割字符串，使用<code>split()</code>方法，并且传入的是正则表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"A,B,C,D"</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">"\\,"</span>); <span class="comment">// &#123;"A", "B", "C", "D"&#125;</span></span><br></pre></td></tr></table></figure><p><strong>字符串连接</strong></p><p>运算符两侧的操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串然后再进行连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Hello"</span>;</span><br><span class="line">String s2 = <span class="string">"World! "</span>;</span><br><span class="line">String s = s1 + s2; <span class="comment">//HelloWorld!</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h6&gt;&lt;p&gt;&lt;strong&gt;String&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Java中，&lt;code&gt;String&lt;/code&gt;是一个引用类型，它本身也是一个&lt;code&gt;class&lt;/code&gt;。但是，Java编译器对&lt;code&gt;String&lt;/code&gt;有特殊处理，即可以直接用&lt;code&gt;&amp;quot;...&amp;quot;&lt;/code&gt;来表示一个字符串：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String s1 = &lt;span class=&quot;string&quot;&gt;&quot;Hello!&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String s2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[] &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;H&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;e&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;l&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;l&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;o&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;!&#39;&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;因为&lt;code&gt;String&lt;/code&gt;太常用了，所以Java提供了&lt;code&gt;&amp;quot;...&amp;quot;&lt;/code&gt;这种字符串字面量表示方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://lwju.xyz/categories/Java/"/>
    
    
      <category term="Java字符串" scheme="http://lwju.xyz/tags/Java%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记(六):面向对象基础(四)</title>
    <link href="http://lwju.xyz/Java/javanote6/"/>
    <id>http://lwju.xyz/Java/javanote6/</id>
    <published>2019-11-11T13:41:02.000Z</published>
    <updated>2019-11-11T13:51:35.130Z</updated>
    
    <content type="html"><![CDATA[<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>由于多态的存在，每个子类都可以覆写父类的方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>Person</code> 类派生的 <code>Student</code>和 <code>Teacher</code> 都可以覆写 <code>run()</code> 方法。如果父类 <code>Person</code> 的<code>run()</code>方法没有实际意义，能否去掉方法的执行语句？</p><p>如果父类<code>Person</code> 的<code>run()</code>方法没有实际意义，能否去掉方法的执行语句？</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; <span class="comment">// Compile Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是不行，会导致编译错误，因为定义方法的时候，必须实现方法的语句。</p><p>能不能去掉父类的<code>run()</code>方法？</p><p>答案还是不行，因为去掉父类的<code>run()</code>方法，就失去了多态的特性。例如，<code>runTwice()</code> 就无法编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTwice</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    p.run(); <span class="comment">// Person没有run()方法，会导致编译错误</span></span><br><span class="line">    p.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一个方法声明为 <code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code> 类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。</p><p>必须把 <code>Person</code>类本身也声明为 <code>abstract</code>，才能正确编译它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象类</strong><br>如果一个 <code>class</code> 定义了方法，但没有具体的执行代码，这个方法就是抽象方法，抽象方法用 <code>abstract</code>修饰。</p><p>因为无法执行抽象方法因此这个类也必须申明为<strong>抽象类(abstract class)</strong>。</p><p>使用 <code>abstract</code> 修饰的类就是抽象类。我们无法实例化一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(); <span class="comment">// 编译错误`</span></span><br></pre></td></tr></table></figure><p>无法实例化的抽象类有什么用？</p><p>因为抽象类本身背设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p><p>例如，<code>Person</code> 类定义了抽象方法 <code>run()</code>，那么，在实现子类<code>Student</code> 的时候，就必须覆写<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abstract class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>在抽象类中，抽象方法本质是定义接口规范：即规定高层类的接口，从而保证所有子类都想相同的接口实现，这样，多态就能发挥出威力</p><p>如果一个抽象类没有字段，所有的方法全部是抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以把该抽象类写为接口：<code>interface</code>。</p><p><strong>接口的定义</strong></p><p>在Java中，使用<code>interface</code>可以声明一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓 <code>interface</code>，就是不抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是 <code>public abstract</code>的，所以这两个修饰符不需要写出来(写不写效果都一样)。</p><p><strong>接口的实现</strong></p><p>当一个具体的class 去实现一个interface时，需要使用implements关键字。<br>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Hello</span> </span>&#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象类和接口的对比如下：</strong></p><table><thead><tr><th align="center"></th><th align="center">abstract class</th><th align="center">interface</th></tr></thead><tbody><tr><td align="center">继承</td><td align="center">一个子类只能有一个直接父类</td><td align="center">一个类可以实现多个接口</td></tr><tr><td align="center">字段</td><td align="center">可以定义实例字段</td><td align="center">不能定义实例字段</td></tr><tr><td align="center">抽象方法</td><td align="center">可以定义抽象方法</td><td align="center">可以定义抽象方法</td></tr><tr><td align="center">非抽象方法</td><td align="center">可以定义非抽象方法</td><td align="center">可以定义default方法</td></tr></tbody></table><p><strong>接口继承</strong></p><p>一个 <code>interface</code> 可以继承自另一个 <code>interface</code>。<code>interface</code> 继承自 <code>interface</code> 使用 <code>extends</code>，它相当于扩展了接口的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>Person</code> 接口继承自 <code>Hello</code> 接口，因此，<code>Person</code> 接口现在实际上有3个抽象方法签名，其中一个来自继承的 <code>Hello</code> 接口。</p><p><strong>default方法</strong></p><p>在接口中，可以定义 <code>default</code>方法。例如，把 <code>Person</code> 接口的<code>run()</code>方法改为<code>default</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">" run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类可以不必覆写 <code>default</code> 方法。<code>default</code> 方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是 <code>default</code> 方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。<br><code>default</code> 方法和抽象类的普通方法是有所不同的。因为 <code>interface</code> 没有字段，<code>default</code> 方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><ol><li>通过 <code>abstract</code> 定义的方法就是抽象方法，它只有定义没有实现。抽象方法定义了子类必须实现的接口规范；</li><li>定义抽象方法的class必须被定义为抽象类；从抽象类继承的子类必须实现抽象方法；</li><li>如果不实现抽象方法 则改子类仍是一个抽象类；</li><li>面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。</li><li>Java的接口(interface) 定义了纯抽象规范，一个类可以实现多个接口；</li><li>接口也是数据类型，适用于向上转型和向下转型；</li><li>接口的所有方法都是抽象方法，接口不能定义实例字段；</li></ol><p>注：笔记摘录于廖雪峰老师的Java教程，<strong>浅出易懂</strong>非常适合初学者学习！<br><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816" target="_blank" rel="noopener">廖雪峰的官方网站</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h4&gt;&lt;p&gt;由于多态的存在，每个子类都可以覆写父类的方法，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; … &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; … &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; … &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从 &lt;code&gt;Person&lt;/code&gt; 类派生的 &lt;code&gt;Student&lt;/code&gt;和 &lt;code&gt;Teacher&lt;/code&gt; 都可以覆写 &lt;code&gt;run()&lt;/code&gt; 方法。如果父类 &lt;code&gt;Person&lt;/code&gt; 的&lt;code&gt;run()&lt;/code&gt;方法没有实际意义，能否去掉方法的执行语句？&lt;/p&gt;
&lt;p&gt;如果父类&lt;code&gt;Person&lt;/code&gt; 的&lt;code&gt;run()&lt;/code&gt;方法没有实际意义，能否去掉方法的执行语句？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://lwju.xyz/categories/Java/"/>
    
    
      <category term="Java抽象" scheme="http://lwju.xyz/tags/Java%E6%8A%BD%E8%B1%A1/"/>
    
      <category term="Java接口" scheme="http://lwju.xyz/tags/Java%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记(五):面向对象基础( 三)</title>
    <link href="http://lwju.xyz/Java/javanote5/"/>
    <id>http://lwju.xyz/Java/javanote5/</id>
    <published>2019-11-11T13:24:08.000Z</published>
    <updated>2019-11-11T13:44:47.599Z</updated>
    
    <content type="html"><![CDATA[<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承可以在现有类的基础上派出新类。新类继承一般类的状态和行为，并根据需要增加它自己的新的状态和行为。</p><p>由继承得到的类称为子类，被继承的类称为父类。</p><p>继承让我们更加容易实现类的扩展。 比如，我们定义了人类，再定义 Boy 类就只需要扩展人类即可。实现了代码的重用，不用再重新发明轮子(don’t reinvent wheels)。</p><a id="more"></a><p>我们已经定义了 <code>Person</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，假设需要定义一个 <code>Student</code> 类，字段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察，发现<code>Student</code>类包含了<code>Person</code>类已有的字段和方法，只是多出了一个<code>score</code>字段和相应的<code>getScore()</code>、<code>setScore()</code>方法。</p><p>能不能在<code>Student</code>中不要写重复的代码？</p><p>这个时候，继承就派上用场了。</p><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person继</code>承时， <code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p><p>Java 使用<code>extends</code>关键字来实现继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，通过继承，<code>Student</code> 只需要编写额外的功能，不再需要重复代码。</p><p>OOP 的术语中，我们把<code>Person</code>称为超类（super class），父类（parent class），基类（base class），把<code>Student</code>称为子类（subclass），扩展类（extended class）。</p><p>Java 只允许一个 class 继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</p><p><strong>1.2 protected</strong></p><p>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name; <span class="comment">// 编译错误：无法访问name字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name; <span class="comment">// OK!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问.。</p><p><strong>1.3 super 关键字</strong></p><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + <span class="keyword">super</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p><p>但是，在某些时候，就必须使用<code>super</code>。我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">"Xiao Ming"</span>, <span class="number">12</span>, <span class="number">89</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码，会得到一个编译错误，大意是在<code>Student</code>的构造方法中，无法调用<code>Person</code>的构造方法。</p><p>这是因为在 Java 中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code>，所以，<code>Student</code> 类的构造方法实际上是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 自动调用父类的构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p><p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age); <span class="comment">// 调用父类的构造方法Person(String, int)</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以正常编译了！</p><p>因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</p><p>这里还顺带引出了另一个问题：即子类<code>不会继承</code>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p><p><strong>1.4 向上转型</strong></p><blockquote><p>父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。</p><p>如果一个引用变量类型是<code>Student</code>，那么它可以指向一<code>个Student</code>类型的实例：</p></blockquote><p><code>Student s = new Student();</code></p><p>如果一个引用类型的变量是<code>Person</code>，那么它可以指向一个<code>Person</code>类型的实例：</p><p><code>Person p = new Person();</code></p><p>现在问题来了：如果<code>Student</code>是从 <code>Person</code> 继承下来的，那么，一个引用类型为 <code>Person</code> 的变量，能否指向<code>Student</code>类型的实例？</p><p><code>Person p = new Student(); // ???</code></p><p>测试一下就可以发现，这种指向是允许的！</p><p>这是因为 <code>Student</code> 继承自 <code>Person</code>，因此，它拥有 <code>Person</code> 的全部功能。<code>Person</code>类型的变量，如果指向<code>Student</code>类型的实例，对它进行操作，是没有问题的！</p><p>这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。向上转型实际上是把一个子类型安全地变为更加抽象的父类型。</p><p><strong>1.5 向下转型</strong></p><blockquote><p>向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型!</p></blockquote><p>如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Student(); // upcasting, ok</span><br><span class="line">Person p2 = new Person();</span><br><span class="line">Student s1 = (Student) p1; // ok</span><br><span class="line">Student s2 = (Student) p2; // runtime error! ClassCastException!</span><br></pre></td></tr></table></figure><p>如果测试上面的代码，可以发现：</p><p><code>Person</code> 类型 <code>p1</code> 实际指向 <code>Student</code> 实例，<code>Person</code>类型变量 <code>p2</code> 实际指向 <code>Person</code> 实例。在向下转型的时候，把 <code>p1</code> 转型为 <code>Student</code> 会成功，因为 <code>p1</code> 确实指向 <code>Student</code> 实例，把 <code>p2</code> 转型为 <code>Student</code>会失败，因为 <code>p2</code> 的实际类型是 <code>Person</code>，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p><p>因此，向下转型很可能会失败。失败的时候，Java 虚拟机会报<code>ClassCastException</code>。</p><p>为了避免向下转型出错，Java 提供了<code>instanceof</code>操作符，可以<strong>先判断一个实例究竟是不是某种类型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Student n = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(n <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code> 际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为 <code>null</code>，那么对任何 <code>instanceof</code> 的判断都为 <code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    <span class="comment">// 只有判断成功才会向下转型:</span></span><br><span class="line">    Student s = (Student) p; <span class="comment">// 一定会成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>在继承关系中，子类如果定义了一个与父类方法签名相同的方法完全相同的方法，被称为<strong>覆写（Overrride）</strong>。</p><p>多态的要点：</p><ol><li><p>多态是方法的多态，不是属性的多态(多态与属性无关)。</p></li><li><p>多态的存在要有 3 个必要条件：继承，方法重写，父类引用指向子类对象。</p></li><li><p>父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。</p></li></ol><p>例如，在 <code>Person</code> 类中，我们定义了<code>run()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类 <code>Student</code> 中，覆写这个 <code>run()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Override</strong>和<strong>Overload</strong>不同的是：</p><ul><li>如果方法签名不同，就是 Overload，Overload 方法是一个新方法。</li><li>如果方法的签名相同，并且返回值也相同，就是 Override。</li></ul><p><strong>注意：</strong> 方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在 Java 程序中，出现这种情况，编译器会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不是Override，因为参数不同:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String s)</span> </span>&#123; … &#125;</span><br><span class="line">    <span class="comment">// 不是Override，因为返回值不同:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上 <code>@Override</code> 可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。</p><p>但是@Override 不是必需的。</p><p>在上一节中，我们已经知道，引用变量的声明类型可能与其实际类型不符，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure><p>现在，我们考虑一种情况，如果子类覆写了父类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        p.run(); <span class="comment">// 应该打印Person.run还是Student.run?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，一个实际类型为 <code>Student</code>，引用类型为 <code>Person</code> 的变量，调用其 <code>run()</code> 方法，调用的是<code>Person</code> 还是 <code>Student</code> 的 <code>run()</code> 方法？</p><p>运行一下上面的代码就可以知道，实际上调用的方法是 <code>Student</code> 的 <code>run()</code> 方法。因此可得出结论：</p><p>Java 的实例方法调用时基于运行时的实际类型动态调用，而非变量的声明类型。</p><p>这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。</p><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.run(); <span class="comment">// 无法确定运行时究竟调用哪个run()方法</span></span><br></pre></td></tr></table></figure><p>从上面的代码一看就明白，肯定调用的是 <code>Student</code> 的 <code>run()</code> 方法啊。</p><p>但是，假设我们编写这样一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTwice</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    p.run();</span><br><span class="line">    p.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它传入的参数类型是 <code>Person</code>，我们是无法知道传入的参数实际类型究竟是 <code>Person</code>，还是 <code>Student</code>，还是 <code>Person</code> 的其他子类，因此，也无法确定调用的是不是 <code>Person</code> 类定义的 <code>run()</code> 方法。</p><p>所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</p><p>假设我们定义一种收入，需要给它报税，那么先定义一个 <code>Income</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于工资收入，可以减去一个基数，那么我们可以从 <code>Income</code> 派生出 <code>SalaryIncome</code>，并覆写<code>getTax()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">        total = total + income.getTax();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class="line">        Income[] incomes = <span class="keyword">new</span> Income[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Income(<span class="number">3000</span>),</span><br><span class="line">            <span class="keyword">new</span> Salary(<span class="number">7500</span>),</span><br><span class="line">            <span class="keyword">new</span> StateCouncilSpecialAllowance(<span class="number">15000</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(totalTax(incomes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">            total = total + income.getTax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Income</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.income = income;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Salary</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StateCouncilSpecialAllowance</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察 totalTax()方法：利用多态，totalTax()方法只需要和 Income 打交道，它完全不需要知道 Salary 和 StateCouncilSpecialAllowance 的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从 Income 派生，然后正确覆写 getTax()方法就可以。把新的类型传入 totalTax()，不需要修改任何代码。</p><p>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p><p><strong>覆写 Object 方法</strong></p><p>因为所有的 class 最终都继承自 Object，而 Object 定义了几个重要的方法：</p><ul><li>toString()：把 instance 输出为 String；</li><li>equals()：判断两个 instance 是否逻辑相等；</li><li>hashCode()：计算一个 instance 的哈希值。</li></ul><p>在必要的情况下，我们可以覆写 Object 的这几个方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 显示更有意义的字符串:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person:name="</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较是否相等:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当且仅当o为Person类型:</span></span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            Person p = (Person) o;</span><br><span class="line">            <span class="comment">// 并且name字段相同时，返回true:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算hash:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 super</p><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过 super 来调用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student extends Person &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的hello()方法:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hello() + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final</p><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为 final。用 final 修饰的方法不能被 Override：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student extends Person &#123;</span><br><span class="line">    <span class="comment">// compile error: 不允许覆写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为 final。用 final 修饰的类不能被继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile error: 不允许继承自Person</span></span><br><span class="line">Student extends Person &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个类的实例字段，同样可以用 final 修饰。用 final 修饰的字段在初始化后不能被修改。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name = <span class="string">"Unamed"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 final 字段重新赋值会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">"New Name"</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>可以在构造方法中初始化 final 字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法更为常用，因为可以保证实例一旦创建，其 final 字段就不可修改。</p><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h6><ol><li><p>继承是面向对象编程的一种强大的代码复用方式；</p></li><li><p>Java 只允许单继承，所有类最终的根类是 Object；</p></li><li><p>protected 允许子类访问父类的字段和方法；</p></li><li><p>子类的构造方法可以通过 super()调用父类的构造方法；</p></li><li><p>可以安全地向上转型为更抽象的类型；</p></li><li><p>可以强制向下转型，最好借助 instanceof 判断；</p></li><li><p>子类和父类的关系是 is，has 关系不能用继承。</p></li><li><p>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；</p></li><li><p>Java 的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</p></li><li><p>final 修饰符有多种作用：</p></li></ol><ul><li>final 修饰的方法可以阻止被覆写；</li><li>final 修饰的 class 可以阻止被继承；</li><li>final 修饰的 field 必须在创建对象时初始化，随后不可修改。</li></ul><p>注：笔记摘录于廖雪峰老师的 Java 教程，<strong>浅出易懂</strong>非常适合初学者学习！<br><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816" target="_blank" rel="noopener">廖雪峰的官方网站</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h4&gt;&lt;p&gt;继承可以在现有类的基础上派出新类。新类继承一般类的状态和行为，并根据需要增加它自己的新的状态和行为。&lt;/p&gt;
&lt;p&gt;由继承得到的类称为子类，被继承的类称为父类。&lt;/p&gt;
&lt;p&gt;继承让我们更加容易实现类的扩展。 比如，我们定义了人类，再定义 Boy 类就只需要扩展人类即可。实现了代码的重用，不用再重新发明轮子(don’t reinvent wheels)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://lwju.xyz/categories/Java/"/>
    
    
      <category term="Java继承" scheme="http://lwju.xyz/tags/Java%E7%BB%A7%E6%89%BF/"/>
    
      <category term="Java多态" scheme="http://lwju.xyz/tags/Java%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记(四):面向对象基础(二)</title>
    <link href="http://lwju.xyz/Java/javanote4/"/>
    <id>http://lwju.xyz/Java/javanote4/</id>
    <published>2019-11-11T13:12:56.000Z</published>
    <updated>2019-11-11T13:44:59.546Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、方法的重载"><a href="#一、方法的重载" class="headerlink" title="一、方法的重载"></a>一、方法的重载</h5><p>  &nbsp;&nbsp; 方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。 调用时，会根据不同的参数自动匹配对应的方法。</p><p>&nbsp;&nbsp;在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。例如，在Hello类中，定义多个hello()方法：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, "</span> + name + <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Hi, "</span> + name + <span class="string">"!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello, "</span> + name + <span class="string">"!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法名相同，但各自的参数不同，称为方法的重载（<code>Overload</code>）。</p><p><strong>注意：</strong> 方法重载的返回值类型通常都是相同的。</p><p>方法重载的目的是，功能类似的方法使用同一个名字，更容易记住，因此调用起来更简单。</p><p>举个例子，String类提供了多个重载方法<code>indexof()</code>，可以查找子串：</p><ul><li><code>int indexof(int ch)</code>：根据字符的Unicode码查找；</li><li><code>int indexof(String str)</code>：根据字符串查找；</li><li><code>int indexof(int ch,int fromIndex)</code>：根据字符查找，但指定起始位置；</li><li><code>int indexof(String str,int fromIdex)</code>：根据字符串查找，但是指定起始位置。</li></ul><p><strong>构成方法重载的条件：</strong></p><ol><li><p>不同的含义： 形参类型、形参个数、形参顺序不同</p></li><li><p>重载方法返回值类型应该相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法的重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test21</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(add(<span class="number">3</span>, <span class="number">5</span>));<span class="comment">// 8</span></span><br><span class="line">        System.out.println(add(<span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>));<span class="comment">// 18</span></span><br><span class="line">        System.out.println(add(<span class="number">3.0</span>, <span class="number">5</span>));<span class="comment">// 8.0</span></span><br><span class="line">        System.out.println(add(<span class="number">3</span>, <span class="number">5.0</span>));<span class="comment">// 8.0</span></span><br><span class="line">        <span class="comment">// 我们已经见过的方法的重载</span></span><br><span class="line">        System.out.println();<span class="comment">// 0个参数</span></span><br><span class="line">        System.out.println(<span class="number">1</span>);<span class="comment">// 参数是1个int</span></span><br><span class="line">        System.out.println(<span class="number">3.0</span>);<span class="comment">// 参数是1个double</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 求和的方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法名相同，参数个数不同，构成重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> n3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n1 + n2 + n3;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法名相同，参数类型不同，构成重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法名相同，参数顺序不同，构成重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">double</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译错误：只有返回值不同，不构成方法的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译错误：只有参数名称不同，不构成方法的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n2, <span class="keyword">int</span> n1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = n1 + n2;         </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>重载方法应该完成类似的功能。</p></blockquote></li></ol><h5 id="二、构造方法的重载"><a href="#二、构造方法的重载" class="headerlink" title="二、构造方法的重载"></a>二、构造方法的重载</h5><p>构造方法也是方法，只不过有特殊的作用而已。与普通方法一样，构造方法也可以重载<br><strong>示例：</strong> 构造方法重载(创建不同用户对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">// id</span></span><br><span class="line">    String name; <span class="comment">// 账户名</span></span><br><span class="line">    String pwd; <span class="comment">// 密码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User();</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">101</span>, <span class="string">"高小七"</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">100</span>, <span class="string">"高淇"</span>, <span class="string">"123456"</span>);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 如果方法构造中形参名与属性名相同时，需要使用this关键字区分属性与形参。<br>this.id 表示属性id;id表示形参id</p></blockquote><h5 id="三、this关键字"><a href="#三、this关键字" class="headerlink" title="三、this关键字"></a>三、this关键字</h5><p><strong>对象创建的过程和this的本质</strong></p><p>&nbsp; &nbsp;构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为四步：</p><ol><li><p>分配对象空间，并将对象成员变量初始化为0或空</p></li><li><p>执行属性值的显示初始化</p></li><li><p>执行构造方法</p></li><li><p>返回对象的地址给相关的变量</p><p>this的本质就是“创建好的对象地址”由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“<strong>当前对象</strong>”。<br>this 最常用的用法：</p><ol><li>在程序中产生二义性之外，应使用this来指明当前对象，<strong>普通方法中</strong>，this总是指向调用该方法的对象。<strong>构造方法中，</strong> this总是指向正要初始化的对象。</li><li>使用this关键字<strong>调用重载的构造方法</strong>，避免相同的初始化代码，但只能在构造方法中用，并且必须位于<strong>构造方法的第一句</strong>。</li><li>this不能用于static方法中。</li></ol></li></ol><p><strong>this代表“当前对象”示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;        <span class="comment">//id</span></span><br><span class="line">    String name;   <span class="comment">//账户名</span></span><br><span class="line">    String pwd;   <span class="comment">//密码</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在初始化已经创建好的对象："</span>+<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.id = id;   <span class="comment">//不写this，无法区分局部变量id和成员变量id</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">",要登录！"</span>);  <span class="comment">//不写this效果一样</span></span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User  u3 = <span class="keyword">new</span> User(<span class="number">101</span>,<span class="string">"高小七"</span>);</span><br><span class="line">        System.out.println(<span class="string">"打印高小七对象："</span>+u3);</span><br><span class="line">        u3.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>this()调用重载构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line"> </span><br><span class="line">    TestThis() &#123;</span><br><span class="line">        System.out.println(<span class="string">"正要初始化一个Hello对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TestThis(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="comment">// TestThis(); //这样是无法调用构造方法的！</span></span><br><span class="line">        <span class="keyword">this</span>(); <span class="comment">// 调用无参的构造方法，并且必须位于第一行！</span></span><br><span class="line">        a = a;<span class="comment">// 这里都是指的局部变量而不是成员变量</span></span><br><span class="line"><span class="comment">// 这样就区分了成员变量和局部变量. 这种情况占了this使用情况大多数！</span></span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    TestThis(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">this</span>(a, b); <span class="comment">// 调用带参的构造方法，并且必须位于第一行！</span></span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sing(); <span class="comment">// 调用本类中的sing();</span></span><br><span class="line">        System.out.println(<span class="string">"你妈妈喊你回家吃饭！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThis hi = <span class="keyword">new</span> TestThis(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        hi.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="四、静态字段和静态方法"><a href="#四、静态字段和静态方法" class="headerlink" title="四、静态字段和静态方法"></a>四、静态字段和静态方法</h5><p><strong>静态字段</strong></p><p>在一个 <code>class</code>中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p><p>还有一种字段，是用static修饰的字段，称为静态字段：<code>static field</code>。 </p><p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例。</p><p>虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。</p><p>因此，不推荐用实例 <em><code>变量.静态字段</code></em> 去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为 <em><code>类名.静态字段</code></em> 来访问静态对象。</p><p>推荐用类名来访问静态字段。可以把静态字段理解为描述<code>class</code>本身的字段（非实例字段）。对于上面的代码，更好的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.number = <span class="number">99</span>;</span><br><span class="line">System.out.println(Person.number);</span><br></pre></td></tr></table></figure><p><strong>静态方法</strong></p><p>有静态字段，就有静态方法。用static修饰的方法称为静态方法。</p><p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person.setNumber(<span class="number">99</span>);</span><br><span class="line">        System.out.println(Person.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        number = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。</p><p>通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。</p><p>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。静态方法经常用于工具类。例如：<br>Arrays.sort()<br>Math.random()</p><p>静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。</p><p><strong>接口的静态字段</strong></p><p>因为interface是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为final类型：</p><p>实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会自动把该字段变为public static final类型。</p><p><strong>小结：</strong>　　</p><ol><li><p>静态字段属于所有实例“共享”的字段，实际上是属于class的字段；</p></li><li><p>调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法；</p></li><li><p>静态方法常用于工具类和辅助方法。</p></li><li><p>一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。)　　</p></li><li><p>在static方法中不可直接访问非static的成员。</p></li></ol><h6 id="扩展-：-JDK中的主要包"><a href="#扩展-：-JDK中的主要包" class="headerlink" title="扩展 ： JDK中的主要包"></a><strong>扩展 ：</strong> JDK中的主要包</h6><table><thead><tr><th>Java中的常用包</th><th>说明</th></tr></thead><tbody><tr><td>java.lang</td><td>包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。</td></tr><tr><td>java.awt</td><td>包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。</td></tr><tr><td>java.net</td><td>包含执行与网络相关的操作的类。</td></tr><tr><td>java.io</td><td>包含能提供多种输入/输出功能的类。</td></tr><tr><td>java.util</td><td>包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。</td></tr></tbody></table><p>注：笔记摘录于廖雪峰老师的Java教程，<strong>浅出易懂</strong>非常适合初学者学习！<br><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816" target="_blank" rel="noopener">廖雪峰的官方网站</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、方法的重载&quot;&gt;&lt;a href=&quot;#一、方法的重载&quot; class=&quot;headerlink&quot; title=&quot;一、方法的重载&quot;&gt;&lt;/a&gt;一、方法的重载&lt;/h5&gt;&lt;p&gt;  &amp;nbsp;&amp;nbsp; 方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。 调用时，会根据不同的参数自动匹配对应的方法。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。例如，在Hello类中，定义多个hello()方法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://lwju.xyz/categories/Java/"/>
    
    
      <category term="Java方法重载" scheme="http://lwju.xyz/tags/Java%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记(三):面向对象基础(一)</title>
    <link href="http://lwju.xyz/Java/javanote3/"/>
    <id>http://lwju.xyz/Java/javanote3/</id>
    <published>2019-11-11T13:01:40.000Z</published>
    <updated>2019-11-11T13:45:30.740Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p><p>现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）：</p><table><thead><tr><th align="center">现实世界</th><th align="center">计算机模型</th><th align="center">Java代码</th></tr></thead><tbody><tr><td align="center">人</td><td align="center">类/class</td><td align="center">class Person { }</td></tr><tr><td align="center">小明</td><td align="center">实例/ming</td><td align="center">Person ming = new Person</td></tr><tr><td align="center">小红</td><td align="center">实例/hong</td><td align="center">Person hong = new Person</td></tr><tr><td align="center">小军</td><td align="center">实例/jun</td><td align="center">Person jun = new Person</td></tr></tbody></table><a id="more"></a><p>同样的，“书”也是一种抽象的概念，所以它是类，而《Java核心技术》、《Java编程思想》、《Java学习笔记》则是实例：</p><table><thead><tr><th align="center">现实世界</th><th align="center">计算机模型</th><th align="center">Java代码</th></tr></thead><tbody><tr><td align="center">书</td><td align="center">类/class</td><td align="center">class Book { }</td></tr><tr><td align="center">Java核心技术</td><td align="center">实例/book1</td><td align="center">Book book1 = new Book</td></tr><tr><td align="center">Java核心技术</td><td align="center">实例/book2</td><td align="center">Book book2 = new Book</td></tr><tr><td align="center">Java核心技术</td><td align="center">实例/book3</td><td align="center">Book book3 = new Book</td></tr></tbody></table><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p>只要理解class和instance的概念，基本上就明白了什么是面向对象编程。class是一种对象模版，它定义了如何创建实例，因此，class本身就是一种数据类型。</p><p>而instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同。</p><p><strong>1.2 定义class</strong></p><p>在Java中，创建一个类，例如，给这个类命名为Person，就是定义一个class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个class可以包含多个字段（field），字段用来描述一个类的特征。上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。因此，通过class，把一组数据汇集到一个对象上，实现了数据封装。</p></blockquote><blockquote><p>public是用来修饰字段的，它表示这个字段可以被外部访问。</p></blockquote><p><strong>1.3 创建实例</strong></p><p>定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。</p><p>new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例：</p><p><code>Person ming = new Person();</code></p><p>上述代码创建了一个Person类型的实例，并通过变量ming指向它。</p><blockquote><p>注意区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例。</p></blockquote><p>有了指向这个实例的变量，我们就可以通过这个变量来操作实例。访问实例变量可以用变量.字段，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ming.name = <span class="string">"Xiao Ming"</span>; <span class="comment">// 对字段name赋值</span></span><br><span class="line">ming.age = <span class="number">12</span>; <span class="comment">// 对字段age赋值</span></span><br><span class="line">System.out.println(ming.name); <span class="comment">// 访问字段name</span></span><br><span class="line"></span><br><span class="line">Person hong = <span class="keyword">new</span> Person();</span><br><span class="line">hong.name = <span class="string">"Xiao Hong"</span>;</span><br><span class="line">hong.age = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>Java中的类行为由类的成员方法来实现，类的成员方法有方法声明和方法体组成</p><h5 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] &lt;方法返回类型&gt; &lt;方法名&gt; ([方法参数列表]) &#123;</span><br><span class="line">    若干方法语句;</span><br><span class="line">    <span class="keyword">return</span> 方法返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。</p><blockquote><p>[修饰符] 用于指定方法的访问权限，可选值为public、private、protected。 </p></blockquote><p><strong>private方法</strong></p><p>有public方法，自然就有private方法。和private字段一样，private方法不允许外部调用，那我们定义private方法有什么用？</p><p>定义private方法的理由是内部方法是可以调用private方法的。例如：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person ming = <span class="keyword">new</span> Person();</span><br><span class="line">        ming.setBirth(<span class="number">2008</span>);</span><br><span class="line">        System.out.println(ming.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> birth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirth</span><span class="params">(<span class="keyword">int</span> birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calcAge(<span class="number">2019</span>); <span class="comment">// 调用private方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private方法:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calcAge</span><span class="params">(<span class="keyword">int</span> currentYear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentYear - <span class="keyword">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>观察上述代码，calcAge()是一个private方法，外部代码无法调用，但是，内部方法getAge()可以调用它。</p></blockquote><p><strong>this变量</strong><br>方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的字段。</p><p>如果没有命名冲突，可以省略this。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name; <span class="comment">// 相当于this.name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; <span class="comment">// 前面的this不可少，少了就变成局部变量name了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h5><p>方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNameAndAge</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个setNameAndAge()方法时，必须有两个参数，且第一个参数必须为String，第二个参数必须为int。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person ming = <span class="keyword">new</span> Person();</span><br><span class="line">ming.setNameAndAge(<span class="string">"Xiao Ming"</span>); <span class="comment">// 编译错误：参数个数不对</span></span><br><span class="line">ming.setNameAndAge(<span class="number">12</span>, <span class="string">"Xiao Ming"</span>); <span class="comment">// 编译错误：参数类型不对</span></span><br></pre></td></tr></table></figure><p><strong>可变参数</strong><br>可变参数用类型…定义，可变参数相当于数组类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNames</span><span class="params">(String... names)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的setNames()就定义了一个可变参数。调用时，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Group g = <span class="keyword">new</span> Group();</span><br><span class="line">g.setNames(<span class="string">"Xiao Ming"</span>, <span class="string">"Xiao Hong"</span>, <span class="string">"Xiao Jun"</span>); <span class="comment">// 传入3个String</span></span><br><span class="line">g.setNames(<span class="string">"Xiao Ming"</span>, <span class="string">"Xiao Hong"</span>); <span class="comment">// 传入2个String</span></span><br><span class="line">g.setNames(<span class="string">"Xiao Ming"</span>); <span class="comment">// 传入1个String</span></span><br><span class="line">g.setNames(); <span class="comment">// 传入0个String</span></span><br></pre></td></tr></table></figure><p>完全可以把可变参数改写为String[]类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNames</span><span class="params">(String[] names)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，调用方需要自己先构造String[]，比较麻烦。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Group g = <span class="keyword">new</span> Group();</span><br><span class="line">g.setNames(<span class="keyword">new</span> String[] &#123;<span class="string">"Xiao Ming"</span>, <span class="string">"Xiao Hong"</span>, <span class="string">"Xiao Jun"</span>&#125;); <span class="comment">// 传入1个String[]</span></span><br></pre></td></tr></table></figure><p>另一个问题是，调用方可以传入null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Group g = <span class="keyword">new</span> Group();</span><br><span class="line">g.setNames(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>而可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null。</p><blockquote><p>外部代码通过public方法操作实例，内部代码可以调用private方法；</p></blockquote><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。<br>声明格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 类名(形参列表)&#123;</span><br><span class="line">    <span class="comment">//n条语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例的时候，我们经常需要同时初始化这个实例的字段，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person ming = <span class="keyword">new</span> Person();</span><br><span class="line">ming.setName(<span class="string">"小明"</span>);</span><br><span class="line">ming.setAge(<span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>初始化对象实例需要3行代码，而且，如果忘了调用setName()或者setAge()，这个实例内部的状态就是不正确的。</p><p>能否在创建对象实例时就把内部字段全部初始化为合适的值？</p><p>完全可以。</p><p>这时，我们就需要构造方法。</p><p>创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建Person实例的时候，一次性传入name和age，完成初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"Xiao Ming"</span>, <span class="number">15</span>);</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">        System.out.println(p.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于构造方法是如此特殊，所以构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。</p><h5 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h5><p>是不是任何class都有构造方法？是的。</p><p>那前面我们并没有为Person类编写构造方法，为什么可以调用new Person()？</p><p>原因是如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意的是，如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法：</p><p>如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"Xiao Ming"</span>, <span class="number">15</span>); <span class="comment">// 既可以调用带参数的构造方法</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(); <span class="comment">// 也可以调用无参数构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 默认初始化为null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 默认初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以对字段直接进行初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"Unamed"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了：既对字段进行初始化，又在构造方法中对字段进行初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"Unamed"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们创建对象的时候，<code>new Person(&quot;Xiao Ming&quot;, 12</code>)得到的对象实例，字段的初始值是啥？</p><p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p><ol><li><p>先初始化字段，例如，<code>int age = 10;</code>表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null；</p></li><li><p>执行构造方法的代码进行初始化。</p></li></ol><p>因此，构造方法的代码由于后运行，所以，<code>new Person(&quot;Xiao Min&quot;12);</code>的字段值最终由构造方法的代码确定。多构造方法</p><h5 id="多构造方法"><a href="#多构造方法" class="headerlink" title="多构造方法"></a>多构造方法</h5><p>可以定义多个构造方法，在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用<code>new Person(&quot;Xiao Ming&quot;, 20);</code>，会自动匹配到构造方法<code>public Person(String, int)</code>。</p><p>如果调用<code>new Person(&quot;Xiao Ming&quot;);</code>，会自动匹配到构造方法<code>public Person(String)</code>。</p><p>如果调用<code>new Person();</code>，会自动匹配到构造方法<code>public Person()</code>。一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是<code>this(…)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="number">18</span>); <span class="comment">// 调用另一个构造方法Person(String, int)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"Unnamed"</span>); <span class="comment">// 调用另一个构造方法Person(String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><ol><li><p>实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例；</p></li><li><p>没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法；</p></li><li><p>可以定义多个构造方法，编译器根据参数自动判断；</p></li><li><p>可以在一个构造方法内部调用另一个构造方法，便于代码复用。</p></li><li><p>构造器的方法名必须和类名一致!</p></li></ol><p>注：笔记摘录于廖雪峰老师的Java教程，<strong>浅出易懂</strong>非常适合初学者学习！<br><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816" target="_blank" rel="noopener">廖雪峰的官方网站</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。&lt;/p&gt;
&lt;p&gt;现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;现实世界&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;计算机模型&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Java代码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;人&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;类/class&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;class Person { }&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;小明&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;实例/ming&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Person ming = new Person&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;小红&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;实例/hong&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Person hong = new Person&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;小军&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;实例/jun&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Person jun = new Person&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://lwju.xyz/categories/Java/"/>
    
    
      <category term="Java面向对象" scheme="http://lwju.xyz/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记(二):流程控制语句</title>
    <link href="http://lwju.xyz/Java/javanote2/"/>
    <id>http://lwju.xyz/Java/javanote2/</id>
    <published>2019-11-11T12:45:40.000Z</published>
    <updated>2019-11-11T13:45:39.746Z</updated>
    
    <content type="html"><![CDATA[<h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4><p>1.1 单选泽结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式) &#123;</span><br><span class="line">   语句块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> if 语句对布尔表达式进行一次判定，若判定为真，则执行{}中的语句块，否则跳过该语句块。</p><a id="more"></a><p>1.2 if-else双选择结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"> 语句块<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       语句块<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当布尔表达式为真时，执行语句块1，否则，执行语句块2。也就是else部分。</p><p>1.3 if-else if-else多选择结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>) &#123;</span><br><span class="line">语句块<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>) &#123;</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line">&#125;……</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式n)&#123;</span><br><span class="line">    语句块n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句块n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当布尔表达式1为真时，执行语句块1;否则，判断布尔表达式2，<br>当布尔表达式2为真时，执行语句块2;否则，继续判断布尔表达式3······;<br> 如果1~n个布尔表达式均判定为假时，则执行语句块n+1，也就是else部分。</p><p>1.4 switch多选择结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> 值<span class="number">1</span>: </span><br><span class="line">语句块<span class="number">1</span>;</span><br><span class="line">[<span class="keyword">break</span>];</span><br><span class="line"><span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line"> 语句块<span class="number">2</span>;</span><br><span class="line">[<span class="keyword">break</span>];</span><br><span class="line">     … … …      … …</span><br><span class="line">[<span class="keyword">default</span>:</span><br><span class="line"> 默认语句;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;switch语句会根据表达式的值从相匹配的case标签处开始执行，一直执行到break语句处或者是switch语句的末尾。<br>&nbsp;&nbsp;如果表达式的值与任一case值不匹配，则进入default语句(如果存在default语句的情况)。</p><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p> 循环语句就是重复执行某段程序代码。直到满足特定条件为止。</p><p>2.for循环语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始表达式; 布尔表达式; 操作表达式 &#123;</span><br><span class="line">      循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环语句是一种支持迭代的一种通用结构，利用每次迭代之后更新的计数器或类似的变量值来控制迭代次数。</p><p> <strong>无限循环</strong></p><ul><li><code>while(true)</code></li><li><code>for(;;)</code></li></ul><p>2.2 while循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (布尔表达式) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> &nbsp;&nbsp;在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体。而对于后来每一次额外的循环，都会在开始前重新计算一次。<br>  语句中应有使循环趋向于结束的语句，否则会出现无限循环–––”死”循环。</p><p>2.3 do-while循环<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">        循环体;</span><br><span class="line">     &#125; <span class="keyword">while</span>(布尔表达式) ;</span><br></pre></td></tr></table></figure><br> <code>do-while</code>循环结构会先执行循环体，然后再判断布尔表达式的值，若条件为真，执行循环体，当条件为假时结束循环。do-while循环的循环体<strong>至少执行一次</strong>。</p><p> 2.4嵌套循环</p><p> 在一个循环语句内部再嵌套一个或多个循环，称为嵌套循环。while、do-while与for循环可以任意嵌套多层。<br>3. 跳转语句</p><blockquote><p>跳转语句用于实现执行过程中程序流程的跳转。</p></blockquote><ul><li><code>break</code> 语句 可以终止循环或其他控制结构，用于强行退出循环，不执行循环中剩余的语句。</li><li><code>continue</code> 语句如果在某次循环体的执行中执行了continue语句，那么本次循环结束，进入下一次循环</li></ul><p>3.2 带标签的break和continue  </p><p>“标签”是指后面跟一个冒号的标识符，例如：“label:”。对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。</p><p><strong>注意事项</strong></p><blockquote><ol><li>continue用在while，do-while中，continue 语句立刻跳到循环首部，越过了当前循环的其余部分。</li><li>continue用在for循环中，跳到for循环的迭代因子部分。</li></ol></blockquote><p><strong>3. 递归结构</strong></p><ul><li>递归是一种常见的解决问题的方法，即把问题逐渐简单化。</li></ul><ul><li><p>递归的基本思想就是“自己调用自己”，一个使用递归技术的方法将会直接或者间接的调用自己。</p></li><li><p>利用递归可以用简单的程序来解决一些复杂的问题。比如：斐波那契数列的计算、汉诺塔、快排等问题。</p></li><li><p>递归结构包括两个部分：</p><ul><li><p>1.定义递归头。解答：什么时候不调用自身方法。如果没有头，将陷入死循环，也就是递归的结束条件。</p></li><li><p>2.递归体。解答：什么时候需要调用自身方法。</p></li></ul></li></ul><h4 id="作用域–封装的实现"><a href="#作用域–封装的实现" class="headerlink" title="作用域–封装的实现"></a>作用域–封装的实现</h4><p>在Java中，我们经常看到<code>public</code>、<code>protected</code>、<code>private</code>、<code>default</code>这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。</p><p>它们说明了面向对象的封装性，所以我们要利用它们尽可能的让访问权限降到最低，从而提高安全性。</p><p><strong>1. public</strong>  </p><p>表示可以被该项目的所有包中的所有类访问。    </p><p>被修饰的类属性以及方法不仅可以跨类使用，而且允许跨包访问，被 <code>public</code>修饰的成员，相当于向所有人开放没有被封装或者隐藏。</p><p><strong>2. private</strong></p><p><code>private</code> 表示私有，只有自己类能访问。</p><p>被修饰的类、属性、方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问，被 <code>private</code>修饰的成员，相当于被封装或隐藏了。</p><p><strong>3. default</strong></p><p>default表示没有修饰符修饰，只有同一个包的类能访问。</p><p><strong>4. protected</strong></p><p><code>protected</code>作用于继承关系。protected表示可以被同一个包的类以及其他包中的子类访问</p><p><strong>5. 局部变量</strong></p><p>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</p><p><strong>6. final</strong></p><p>Java还提供了一个<code>final</code>修饰符。<code>final</code>与访问权限不冲突，它有很多作用。</p><p>用<code>final</code>修饰<code>class</code>可以阻止被继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法被继承:public final class Hello &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package abc;</span><br><span class="line"></span><br><span class="line">public class Hello &#123;</span><br><span class="line">    // 无法被覆写:</span><br><span class="line">    protected final void hi() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = <span class="number">1</span>; <span class="comment">// error!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用final修饰局部变量可以阻止被重新赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        t = <span class="number">1</span>; <span class="comment">// error!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>final</code>修饰符不是访问权限，它可以修饰<code>class</code>、<code>field</code>和<code>method</code>；</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;选择结构&quot;&gt;&lt;a href=&quot;#选择结构&quot; class=&quot;headerlink&quot; title=&quot;选择结构&quot;&gt;&lt;/a&gt;选择结构&lt;/h4&gt;&lt;p&gt;1.1 单选泽结构&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(布尔表达式) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   语句块；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; if 语句对布尔表达式进行一次判定，若判定为真，则执行{}中的语句块，否则跳过该语句块。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://lwju.xyz/categories/Java/"/>
    
    
      <category term="Java流程控制" scheme="http://lwju.xyz/tags/Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记(一):基本数据类型和运算符</title>
    <link href="http://lwju.xyz/Java/Javanote1/"/>
    <id>http://lwju.xyz/Java/Javanote1/</id>
    <published>2019-11-11T10:07:25.000Z</published>
    <updated>2019-11-11T10:14:05.085Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.标识符</strong></p><p>标识符是用来给变量、类、方法、以及包进行命名的。</p><a id="more"></a><ul><li>标识符需遵循一定的规则：</li><li>标识符必须以字母、下划线_、美元符号$开头。</li><li>标识符其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合。</li><li>Java 标识符大小写敏感，且长度无限制。</li><li>标识符不可以是Java的关键字。</li></ul><p><strong>标识符的使用规范</strong></p><ul><li>表示类名的标识符：每个单词的首字母大写。</li><li>表示变量和方法的标识符：第一个单词小写，从第二个单词首字母大写，称为“驼峰命名原则”。</li></ul><p><strong>2.变量</strong></p><blockquote><p>变量的定义是： 用来命名一个数据的标识符</p></blockquote><p><code>int year = 1949;</code></p><p>int 是数据类型，表示是整数<br>year 是一个标识符<br>= 是赋值操作符<br>1949 是一个数字类型的值<br>; 表示该行结束<br><strong>2.1变量的基本类型</strong><br>一个变量的类型，决定了该变量可以包含什么样的值。<br>Java中有八种基本类型，都是Java语言预先定义好的，并且是关键字。</p><ul><li><strong>数值型</strong>－ byte、 short、int、 long、float、 double</li><li><strong>字符型</strong>－ char</li><li><strong>布尔型</strong>－boolean </li></ul><p><strong>3.常量</strong><br>常量通常指的是一个固定的值，例如：1、2、3、’a’、’b’、true、false、”helloWorld”等。</p><p><strong>3.1变量和常量命名规范：</strong><br>所有变量、方法、类名：见名知意<br>类成员变量：首字母小写和驼峰原则:  monthSalary<br>局部变量：首字母小写和驼峰原则<br>常量：大写字母和下划线：MAX_VALUE<br>类名：首字母大写和驼峰原则:  Man, GoodMan<br>方法名：首字母小写和驼峰原则: run(), runRun()在Java语言中，主要是利用关键字final来定义一个常量。 常量一旦被初始化后不能再更改其值。<br><strong>4.运算符</strong></p><ul><li><p>算数操作符基本的有：+  -  *  / %</p></li><li><p>自增 自减 :++ –</p></li><li><p>关系操作符: 比较两个变量之间的关系&gt; 大于&gt;= 大于或等于&lt; 小于&lt;= 小于或等于== 是否相等!= 是否不等</p></li><li><p>逻辑运算符<br>&amp; &amp;&amp; 长路与 和 短路与<br>|   ||    长路或 和 短路或<br>!        取反<br>^       异或^</p><ul><li>赋值运算 = </li><li>三元运算  <code>x ? y : z</code></li><li>字符串连接符<br>“+”运算符两侧的操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串然后再进行连接。</li></ul></li></ul><p><strong>5.类型转换</strong></p><blockquote><p>5.1  自动类型转换：容量小的数据类型可以自动转换为容量大的数据类型</p></blockquote><blockquote><p>5.2  强制类型转换，又被称为造型，用于显式的转换一个数值的类型。在有可能丢失信息的情况下进行的转换是通过造型来完成的，但可能造成精度降低或溢出。</p></blockquote><p><strong>语法格式：</strong><br><code>(type)var</code><br>运算符“()”中的type表示将值var想要转换成的目标数据类型</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.标识符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标识符是用来给变量、类、方法、以及包进行命名的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://lwju.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="http://lwju.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Css float浮动</title>
    <link href="http://lwju.xyz/Css/cssfloat/"/>
    <id>http://lwju.xyz/Css/cssfloat/</id>
    <published>2019-11-11T09:49:28.000Z</published>
    <updated>2019-11-11T10:05:06.665Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CSS浮动是什么</strong></p><p>float元素也称为浮动元素，设置了float属性的元素会根据属性值向左或向右浮动。</p><p>浮动元素会从普通文档流中脱离，但浮动元素影响的不仅是自己，它会影响周围的元素对齐进行环绕。</p><p>简单来说，就是让block元素无视float元素，让inline元素让流水一样围绕着float元素来实现浮动布局。 </p><blockquote><p>文字环绕图片是float典型的应用场景。<br>float元素设计的初衷虽然是文字环绕图片,但是目前其最广泛的应用却是在布局领域。</p></blockquote><a id="more"></a><h5 id="浮动带来的问题–高度塌陷"><a href="#浮动带来的问题–高度塌陷" class="headerlink" title="浮动带来的问题–高度塌陷"></a>浮动带来的问题–高度塌陷</h5><blockquote><p>由于设置了float后元素脱离了标准流，从而导致了高度的塌陷，这里有一个很直观的例子</p></blockquote><h5 id="标准流：就是浏览器默认摆放盒子的顺序（从上往下、从左往右）"><a href="#标准流：就是浏览器默认摆放盒子的顺序（从上往下、从左往右）" class="headerlink" title="标准流：就是浏览器默认摆放盒子的顺序（从上往下、从左往右）"></a><strong>标准流：就是浏览器默认摆放盒子的顺序（从上往下、从左往右）</strong></h5><ul><li><p><strong>浮动的元素会脱离标准流（脱标）</strong><br><img src="/images/hehe1.png" alt=""></p></li><li><p><strong>浮动的元素会覆盖在标准流的元素之上</strong><br><img src="/images/fu3.png" alt=""></p></li></ul><ul><li><strong>浮动的规则：浮动找浮动</strong><blockquote><p>浮动元素排列的时候，会找上一个浮动元素的后面<br><img src="/images/fu1.png" alt=""></p></blockquote></li></ul><ul><li><p><strong>浮动的重点：浮动的元素只会影响下面的元素</strong></p><blockquote><p>浮动的元素受到上一个盒子边界的限制（块级元素独占一行）</p></blockquote></li><li><p>浮动的元素有特殊的显示效果</p><ul><li>可以设置宽高<ul><li>行可以显示多个<blockquote><p>注意：浮动元素不能使用text-align或者margin：0 auto居中！</p></blockquote></li></ul></li></ul></li></ul><p><strong>记忆：</strong></p><blockquote><ol><li>浮动元素会脱标 ==&gt; 飘起来了（不占位置） ==&gt; 比标准流高半个级别</li><li>浮动元素会受到上一个盒子边界的影响</li><li>浮动元素可以设置宽高，一行可以显示多个</li></ol></blockquote><h4 id="如何解决塌陷–清除浮动"><a href="#如何解决塌陷–清除浮动" class="headerlink" title="如何解决塌陷–清除浮动"></a>如何解决塌陷–清除浮动</h4><h4 id="清除浮动（清除浮动的影响）"><a href="#清除浮动（清除浮动的影响）" class="headerlink" title="清除浮动（清除浮动的影响）"></a>清除浮动（清除浮动的影响）</h4><blockquote><p>浮动带来的问题：浮动元素撑不开父级容器</p></blockquote><h3 id="清除浮动主流方法有两种"><a href="#清除浮动主流方法有两种" class="headerlink" title="清除浮动主流方法有两种:"></a>清除浮动主流方法有两种:</h3><blockquote><p>(1）使用clear属性清除浮动；<br>(2）给父元素设置 overflow:hidden;</p></blockquote><h4 id="1-利用clear属性"><a href="#1-利用clear属性" class="headerlink" title="1.利用clear属性"></a>1.利用clear属性</h4><p>在父元素里面的最后的添加一个块级元素给添加的块级元素设置清除浮动的核心代码 clear:both;</p><blockquote><p>缺点： 需要在页面中添加额外的标签，让页面的HTML结构变得更加复杂 有违结构与表现的分离</p></blockquote><p><strong>方式一：在设置float的兄弟元素最后设置一个元素，对其设置clear属性，如下</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.div1</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">background</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.div2</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">height</span><span class="selector-pseudo">:10px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">width</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">background</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.clearfix</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方式二： 方式一的缺点还是很明显的，就是平白无故的新增了一个没有内容的元素，使页面出现冗余；这里可以利用伪元素来达到同样的效果</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">示列一：</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line"><span class="attribute">display</span>:block;  </span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"> 示列二：单伪元素清除法</span><br><span class="line"> 一般伪元素清除法会使用 <span class="selector-class">.clearfix</span> 这个类名</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;    </span><br><span class="line"><span class="comment">/*伪元素必加的属性*/</span>   </span><br><span class="line">       <span class="attribute">content</span>: <span class="string">''</span>; </span><br><span class="line"><span class="comment">/*转换为块级元素*/</span>  </span><br><span class="line">      <span class="attribute">display</span>: block; </span><br><span class="line"><span class="comment">/*清除浮动的核心代码*/</span>   </span><br><span class="line">       <span class="attribute">clear</span>: both;</span><br><span class="line"><span class="comment">/*其实有上面三个属性已经可以生效了，但是可能在开发的时候，会有额外的几个属性！！*/</span></span><br><span class="line"><span class="comment">/*目的：在页面中看不到伪元素*/</span>  </span><br><span class="line"><span class="comment">/*避免生成内容破坏原有布局的高度。*/</span></span><br><span class="line">       <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">       <span class="attribute">line-height</span>: <span class="number">0</span>; </span><br><span class="line"><span class="comment">/*使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;*/</span></span><br><span class="line">       <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><blockquote><p>伪元素由CSS渲染，不会增加额外的html标签（兼容性各方面综合最佳）</p></blockquote><h4 id="2-使用-overflow-清除浮动"><a href="#2-使用-overflow-清除浮动" class="headerlink" title="2.使用 overflow 清除浮动"></a>2.使用 overflow 清除浮动</h4><p>在某些特定场景下使用不了步骤：直接给父元素设置 overflow:hidden;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line"><span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优点：不存在结构和语义化问题，代码量极少</p></blockquote><blockquote><p>缺点：overflow:hidden 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素； overflow:auto多层嵌套后，firefox与IE 可能会出现显示错误；</p></blockquote><h5 id="3-设置高度"><a href="#3-设置高度" class="headerlink" title="3.设置高度"></a>3.设置高度</h5><blockquote><p>直接给父元素设置高度 简单粗暴，但是不推荐，不利于后期维护</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;CSS浮动是什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;float元素也称为浮动元素，设置了float属性的元素会根据属性值向左或向右浮动。&lt;/p&gt;
&lt;p&gt;浮动元素会从普通文档流中脱离，但浮动元素影响的不仅是自己，它会影响周围的元素对齐进行环绕。&lt;/p&gt;
&lt;p&gt;简单来说，就是让block元素无视float元素，让inline元素让流水一样围绕着float元素来实现浮动布局。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文字环绕图片是float典型的应用场景。&lt;br&gt;float元素设计的初衷虽然是文字环绕图片,但是目前其最广泛的应用却是在布局领域。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Css" scheme="http://lwju.xyz/categories/Css/"/>
    
    
      <category term="css" scheme="http://lwju.xyz/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS外边距margin重叠和塌陷</title>
    <link href="http://lwju.xyz/Css/css-margin-collapse/"/>
    <id>http://lwju.xyz/Css/css-margin-collapse/</id>
    <published>2019-11-11T09:25:22.000Z</published>
    <updated>2019-11-11T09:43:16.211Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp; &nbsp;  &nbsp; &nbsp;合并现象就是所谓的外边距重叠，当两个垂直外边距相遇时，它们将形成一个外边距。合并的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p><p>&nbsp; &nbsp;  &nbsp; &nbsp;margin 塌陷 是在CSS的盒子模型中出现的一种现象，描述的是当父元素包裹着一个子元素的时候，当给子元素设置margin-top属性时，此时只是想让子元素的边框距离父元素边框有一段距离，而却出现了父元素的顶端距离body这个边框出现了位移，这就是margin-top塌陷的现象。</p><p>  <strong>CSS margin collapse 就是边界塌陷或者说是边界重叠</strong></p><a id="more"></a><h4 id="首先了解下BFC"><a href="#首先了解下BFC" class="headerlink" title="首先了解下BFC"></a>首先了解下BFC</h4><p>  &nbsp; &nbsp;  &nbsp; &nbsp;<strong>BFC</strong>: <code>block formating context</code> - 块级格式化上下文，每一个盒子当中都有一套正常的渲染规则，但是我们可以通过一些语法，来触发bfc，让这个盒子的渲染规则不一样！ 就是这个渲染规则的改变，刚好就解决了margin塌陷的问题，下面是触发bfc的语法：</p><blockquote><ol><li>position： absolute；</li><li>display：inline-block;</li><li>float：left / right;</li><li>overflow: hidden;</li></ol></blockquote><h4 id="BFC作用"><a href="#BFC作用" class="headerlink" title="BFC作用"></a>BFC作用</h4><p><strong>消除Margin Collapse</strong></p><p>在正常情况下，在一个容器内的所有box将会由上至下依次垂直排列，即我们所说的一个元素占一行，并切垂直相邻的距离(即margin)是由各自的margin决定的，而不是两个margin的叠加。</p><h3 id="margin的特殊现象"><a href="#margin的特殊现象" class="headerlink" title="margin的特殊现象"></a>margin的特殊现象</h3><hr><h4 id="margin-重叠现象"><a href="#margin-重叠现象" class="headerlink" title="margin 重叠现象"></a>margin 重叠现象</h4><p>正常情况下: 当两个盒子水平布局时,左右的margin会叠加；<br> 但是当两个盒子垂直布局时，会出现合并现象<br> 两者之间距离全部都为正值，取最大者；没有正值，则都取绝对值，然后用0减去最大值</p><h6 id="正常现象："><a href="#正常现象：" class="headerlink" title="正常现象："></a>正常现象：</h6><blockquote><p>比如：当两个盒子水平布局时，左右的margin会叠加，盒子之间的距离为margin的和。</p></blockquote><h6 id="合并现象："><a href="#合并现象：" class="headerlink" title="合并现象："></a>合并现象：</h6><blockquote><p>当两个盒子垂直布局时，上下的margin会合并，盒子之间的距离为margin的最大值</p></blockquote><h5 id="重叠现象解决方案："><a href="#重叠现象解决方案：" class="headerlink" title="重叠现象解决方案："></a>重叠现象解决方案：</h5><ol><li><strong>相邻元素</strong><ul><li>底部元素设置为浮动 float:left;</li><li>底部元素的position的值为absolute/fixed</li><li>在设置margin-top/bottom值时统一设置上或者下</li></ul></li></ol><ol start="2"><li><strong>嵌套元素</strong></li></ol><ul><li>外层元素添加padding</li><li>外层元素 overflow:hidden;</li><li>外层元素透明边框 border:1px solid transparent;</li><li>内层元素绝对定位 postion:absolute:</li><li>内层元素 加float:left;或display:inline-block;</li></ul><hr><h3 id="margin的塌陷现象（重要）"><a href="#margin的塌陷现象（重要）" class="headerlink" title="margin的塌陷现象（重要）"></a>margin的塌陷现象（重要）</h3><p>互相嵌套的块级元素，垂直外边距会塌陷</p><h4 id="塌陷现象："><a href="#塌陷现象：" class="headerlink" title="塌陷现象："></a>塌陷现象：</h4><p>互相嵌套的块级元素，如果给子元素设置margin-top，此时父元素会一起往下移动！！！</p><h4 id="盒子塌陷"><a href="#盒子塌陷" class="headerlink" title="盒子塌陷"></a>盒子塌陷</h4><p>   &nbsp; &nbsp; 当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文档流），尤其是当父元素的高度为auto时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度就会直接塌陷为零， 我们称这是 CSS 高度塌陷。</p><h4 id="塌陷解决方法"><a href="#塌陷解决方法" class="headerlink" title="塌陷解决方法"></a>塌陷解决方法</h4><ol><li>给父元素增加边框。</li><li>给父盒子加<code>padding-top</code></li><li>给父元素设置<code>display：table;</code></li><li>利用浮动给外部的父盒子也添加浮动，让其也脱离标准文档流，但是对页面的布局不是很好，不易维护。</li><li>给父元素添加<code>position:fixed;</code>定位的知识，将父元素显示在固定位置，就不会受margin-top塌陷的问题影响</li><li>父盒子里最下方引入清除浮动块。最简单的有：<code>&lt;br style=&quot;clear:both;&quot;/&gt;</code></li><li>父盒子设置属性<code>overflow: hidden</code> （该属性触发了父盒子的BFC：块级格式化上下文）<ul><li><code>overflow:auto;</code> 有可能出现滚动条，影响美观。</li><li><code>overflow:hidden;</code> 可能会带来内容不可见的问题。</li></ul></li><li>伪元素清除浮动。<ul><li>外部盒子的after伪元素设置clear属性。</li><li>使用伪元素有一个必加属性 <code>content:&#39;&#39;</code>;content属性值里写标签里面的问题</li><li>伪元素默认是行内元素<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#parent</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">            <span class="attribute">clear</span>: both;</span><br><span class="line">            <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">display</span>: block;</span><br><span class="line">            <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp; &amp;nbsp;  &amp;nbsp; &amp;nbsp;合并现象就是所谓的外边距重叠，当两个垂直外边距相遇时，它们将形成一个外边距。合并的外边距的高度等于两个发生合并的外边距的高度中的较大者。&lt;/p&gt;
&lt;p&gt;&amp;nbsp; &amp;nbsp;  &amp;nbsp; &amp;nbsp;margin 塌陷 是在CSS的盒子模型中出现的一种现象，描述的是当父元素包裹着一个子元素的时候，当给子元素设置margin-top属性时，此时只是想让子元素的边框距离父元素边框有一段距离，而却出现了父元素的顶端距离body这个边框出现了位移，这就是margin-top塌陷的现象。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;CSS margin collapse 就是边界塌陷或者说是边界重叠&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Css" scheme="http://lwju.xyz/categories/Css/"/>
    
    
      <category term="css" scheme="http://lwju.xyz/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>雨后味道</title>
    <link href="http://lwju.xyz/%E9%9A%8F%E7%AC%94/hello-world/"/>
    <id>http://lwju.xyz/随笔/hello-world/</id>
    <published>2019-10-17T14:49:11.645Z</published>
    <updated>2019-11-11T09:16:18.532Z</updated>
    
    <content type="html"><![CDATA[<p> 刚下过雨的窗外，空气弥漫丝丝清爽。树叶经过雨水的洗礼，更显的勃勃生机。虽是初夏，但也沁出令人舒适的凉意。起笔于夜幕临近之际，似乎有一种空无的“古意”，溢于身心。</p><p>一天的忙碌即将结束，提笔回想，这样的“一天已经过去太多了，明天也会是今天与昨天的翻版吗”<br>对于太多人来说，答案是确定的。我身边的亦是如此……..</p><a id="more"></a><blockquote><p>蠢蠢欲动的夏日，闷热难当。这雨又是世间神奇之物，带着一丝清凉，慢慢爬过窗棂，蔓延至屋内，拂去这一身浮躁。</p></blockquote><p> <img src="/images/rain.jpg" alt=""><br> <img src="/images/rain1.jpg" alt=""></p><p> 昨天的雨很突然，前几天的天气特别闷热心情也随之浮躁起来。按计划本来今天是应该去跑步的，结果被突如其来的一场大雨堵在了宿舍，万般心绪也只得暂压心底。吃过晚饭过后就回到了宿舍，下雨的时候给人感觉很舒适，可以放空自己的思绪，没有写文章的琐碎和烦心的焦躁。揣着清凉凉的一颗心望着窗外的大雨。</p><p> 夜幕又一次降临，如约而至。</p><p> 夜晚不像晌午那么浮躁，不像清晨那么慌忙。终于有这么一个安静的时间，可以让自己回想着一些过往，想着不妨乘着记忆尚未遗失，在这里记下曾经自己的一些生活经历，或许日后可以翻出来给自己看看，让自己了解一些遥远的故事和这里真实发生过的一切。</p><hr><p> 六月又是一场盛大的毕业季，是分别亦是开始。后天又是一年一度的高考拉开了帷幕，为此等待的莘莘学子奔赴考场，祝赴考学子旗开得胜。此时内心有些复杂,那种感慨…..不由得把自己的思绪拉回到了职高散漫懒惰的生活,由于某些原因我选择了单招没有参加高考，内心没有遗憾是假的，毕竟当初的我也是励志要参加高考。回忆起来不知道我那几年究竟干了什么，职高的生活过的浑浑噩噩，就这样一天天的开始、结束开始、结束，仿佛就是一个无尽的循环，在这个循环中耗尽自己本应该丰富的生活。</p><p>毕竟人类的大脑都是倾向于舒适和懒惰的，谁都知道花一个或几个小时看看美剧或刷刷微博，是容易的，时间在感知上也是，刷一下就过去了。学英语、学一门新的编程语言、写博客是痛苦的，有时候你甚至会有意识的去避免开始这件事情，先干点这个，再干点那个，熬到最后，发现没时间了，再拿起书来读一会，困了，今天先睡吧。就这样，一天天很快过去了，你发现自己似乎每天都在坚持，但依然没效果。但事实是，你既没坚持，也没效率。</p><p>逐渐思绪又拉回了现实，抬起头，看了眼窗外，依然下着雨。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 刚下过雨的窗外，空气弥漫丝丝清爽。树叶经过雨水的洗礼，更显的勃勃生机。虽是初夏，但也沁出令人舒适的凉意。起笔于夜幕临近之际，似乎有一种空无的“古意”，溢于身心。&lt;/p&gt;
&lt;p&gt;一天的忙碌即将结束，提笔回想，这样的“一天已经过去太多了，明天也会是今天与昨天的翻版吗”&lt;br&gt;对于太多人来说，答案是确定的。我身边的亦是如此……..&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://lwju.xyz/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>大一生活现状</title>
    <link href="http://lwju.xyz/%E9%9A%8F%E7%AC%94/Life/"/>
    <id>http://lwju.xyz/随笔/Life/</id>
    <published>2019-06-23T08:20:24.000Z</published>
    <updated>2019-11-11T09:16:05.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 不管生活怎样总有一道属于你的明媚阳光用你的脚步走出自己的风景</blockquote><p>&ensp; &ensp; 不知不觉大一就这样结束了，没事的时候总喜欢回忆这一年里发生的一切，所以会把回忆记录在博客里， 感觉自己学会了很多knowledge，明白了很多的事理，经历过心态的起伏，但是我一直坚持着做一个真正的我。成长中的自己很开心。</p><a id="more"></a><p>&ensp;　&ensp; 时间向水中的倒影，一晃一学年就过去了，昨日还在埋怨时间过的太慢的情愫似乎还在游移在脑际，而今大二的生活正在向我走来，蓦然回首，感慨颇多。</p><p>&ensp; &ensp;   刚迈入大学的时候对一切似乎都充满新鲜感，但是现在一切归于平静。大一学年我除了完成自己的学习目标,也利用摄影丰富自己的生活,摆脱现在大学生最流行的郁闷日子。</p><p>&ensp; &ensp;  在学习上，我认为还有一样东西是非常重要的，那就是学习态度！我以前对学习的态度不是很端正，常常都是“得过且过”，不过现在好多了，我开始养成一种很好的学习态度。</p><p>&ensp; &ensp; 在生活上，我基本上都可以和同学们友好相处。六个人生活在同一个空间里面，但是各自的生活习性都不相，这就需要大家互相理解和迁就，只有这样才能和平相处，为我们的学习创造一个良好的学习和休息环境。</p><p>&ensp; &ensp; 大学就相当于一个小型的社会，作为一个步入社会的缓冲，我们可以从中学到好多的东西。</p><p>&ensp; &ensp; 大学真的有非常非常多的自由时间，而第一学期自己有一些迷茫则是因为自己没有认真规划自己的时间，忙的时候会手忙脚乱，没有事的时候则闲到发慌，最后导致自己宝贵的时间渐渐溜走，最后发现自己收获很少。而在暑假，我需要更认真的思考这一年自己在生活上的缺点，思考大二自己该如何规划。</p><p>&ensp;  &ensp; 在闲余的时间都用来干嘛？看知乎，偶尔会看一部电影，看书。都是些平常的生活。</p><p>&ensp;  &ensp; 这一年 我渐渐的找到了自己的人生方向，对于现在的生活，每天过的很安静，不停的接触新的知识，这一学年学的知识算是多而不精，现在的方向是往前端学习，这学期刚刚接触了简单的HTML，CSS知识，还在学习JavaScript基础，暑假期间可能是学习的时间不会太多了，等到下学期继续巩固前端所需要的知识框架吧！</p><p>&ensp; &ensp;  期待自己可以在以后的道路中，努力前行，这里摘录一段话” 哪有什么岁月静好，只是有人替你负重前行 “ 。</p><p>&ensp; &ensp; 当我写下这些文字的时候，当你读到这篇文字的时候。代表着我是安静的在仔细地翻阅着我的过去。</p><p>&ensp; &ensp; 在一个安静的环境下 听着的音乐一个人码字，如今也是一种享受。</p><hr><blockquote><p>当一切繁华褪去，才发现，我们，只是，在原地打了个转。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 不管生活怎样
总有一道属于你的明媚阳光
用你的脚步走出自己的风景&lt;/blockquote&gt;

&lt;p&gt;&amp;ensp; &amp;ensp; 不知不觉大一就这样结束了，没事的时候总喜欢回忆这一年里发生的一切，所以会把回忆记录在博客里， 感觉自己学会了很多knowledge，明白了很多的事理，经历过心态的起伏，但是我一直坚持着做一个真正的我。成长中的自己很开心。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://lwju.xyz/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>暗时间</title>
    <link href="http://lwju.xyz/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/DarkTime/"/>
    <id>http://lwju.xyz/时间管理/DarkTime/</id>
    <published>2019-06-23T06:11:35.000Z</published>
    <updated>2019-11-11T09:22:35.778Z</updated>
    
    <content type="html"><![CDATA[<p>如果你有一台计算机，你装了一个系统之后就整天把它搁置在那里，你觉得这台计算机被实际使用了吗？没有。因为CPU整天运行的就是空闲进程。运行空闲进程也是一天，运行大数据量计算的程序也是一天，对于CPU来说同样的一天，价值却是完全不一样的。</p><p>大脑也是如此。</p><a id="more"></a><p>善于利用思维时间的人，可以无形中比别人多出很多时间，从而实际意义上能比别人多活很多年。我们经常听说“心理年龄”这个词，思考得多的人，往往心理年龄更大。有人用10年才能领悟一个道理，因为他们是被动领悟——只有在现实撞到他脸上的时候才感到疼，疼完了之后还是不记得时时提醒自己，结果很快时过境迁抛之脑后，等到第二次遇到同一个坑的时候早忘了曾经跌过跟头了，像这样的效率，除非天天摔坑里，否则遗忘的效率总是大过吃亏长的记性。善于利用思维时间的人则能够在重要的事情上时时主动提醒自己，将临时的记忆变成硬编码的行为习惯。</p><p>每个人的手表都走得一样快，但每个人的生命却不是。衡量一个人生活了多少年，应该用思维时间来计算。举一个极端的例子，如果一个人从生下来开始就呆在一个为他特殊建造的无菌保护室里，没有社会交往，没有知识获取，度过了18年，你会不会认为他成年了？</p><p>认为时间对每个人是均等的是一个错觉，认为别人有一天，我也有一天，其实根本不是这样。如果你正在学习一门专业，你使用自己所投入的天数来衡量，很容易会产生一种错觉，认为投入了不少时间，然而其实，“投入时间”这个说法本身就是荒唐的，实际投入的是时间和效率的乘积。你可以“投入”很多时间在一件事情上面，却发现毫无进展，因为你没有整天把你要做的事情，要学习的东西常驻在你的大脑中，时刻给予它最高的优先级。你走路的时候吃饭的时候，做梦的时候心心念念想的就是这件事情，你的CPU总是分配给它，这个时候你的思维时间就被利用到了极致，你投入的时间就真正等于了实际流逝的时间，因为你的CPU是满载的。</p><p>如果你有做总结的习惯，你在度过一段时间之后总结自己在某某领域投入了多少时间，建议千万不要粗略地去计算有多少天下班后拿起书来翻看过，因为这样你也许会发现书倒是常翻，但领悟却不见得多深，表面上花的时间不少，收益却不见得那么大。因为看书并记住书中的东西只是记忆，并没有涉及推理，只有靠推理才能深入理解一个事物，看到别人看不到的地方，这部分推理的过程就是你的思维时间，也是人一生中占据一个显著比例的“暗时间”，你走路、买菜、洗脸洗手、坐公车、逛街、出游、吃饭、睡觉，所有这些时间都可以成为“暗时间”，你可以充分利用这些时间进行思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。这段时间看起来微不足道，但日积月累将会产生庞大的效应。</p><p>能够充分利用暗时间的人将无形中多出一大块生命，你也许会发现这样的人似乎玩得不比你少，看得不比你多，但不知怎么的就是比你走得更远。比如我就经常发现一些国外的牛人们为什么不仅学习牛逼，连“业余”玩儿的东东也都搞得特牛逼，一点都不业余（上次在《How We Decide》上看到斯坦福的一个牛人，理论物理学博士，同时是世界扑克大赛的前六名保持者，迄今累计奖金拿了六百多万刀），你会奇怪，这些家伙到底哪来的时间，居然可以在不止一个领域做到卓越？</p><p>程序员们都知道，任务切换需要耗费许多额外的花销，通俗地来讲，首先需要保存当前上下文以便下次能够顺利切换回来，然后要加载目标任务的上下文。如果一个系统不停地在多个任务之间来回倒腾，就会耗费大量的时间在上下文切换上，无形中浪费很多的时间。</p><p>相比之下，如果只做一件任务，就不会有此损失。这就是为什么专注的人比不专注的人时间利用效率高得多的原因。任务切换的暗时间看似非常不明显，甚至很多人认为“多任务”是件很好的事情（有时候的确是），但日积月累起来就会发现，消耗在切换上的时间越来越多。</p><p>另外，大脑开始一件任务的时候必须要有一定时间来“热身”，这个时间因人而异，并且可以通过练习来改变。举个例子，你看了一会书之后，忽然感到一阵无聊，忍不住打开浏览器，十分钟后你想起来还要继续看书，但要回复到当时理想的状态，却需要一段时间来努力去集中精力，把记忆中相关的知识全都激活起来，从而才能进入“状态”，因为你上了十分钟网之后这些记忆已经被抑制了。如果这个“热身”状态需要一刻钟，那么看似十分钟的上网闲逛其实就花费了二十五分钟。</p><p>如果阅读的例子还不够生动，对于程序员来说其实有更好的例子：你写程序写得正high，忽然被叫去开了一通会，写到一半的代码搁在那儿。等你开完会回来你需要多久能够重新进入状态？又或者，你正在调试程序，你已经花了二十分钟的时间把与这个bug可能相关的代码前前后后都理解了一遍，心中构建了一个大致的地图，就在这时，呃，你又被叫去开了个会(:D)，开完会回来，可想而知，得花上一些时间来回想一下刚刚弄清的东西了。</p><p>迅速进入状态的能力是可以锻炼的，根据我个人的经验，至少可以缩短到3-5分钟。但要想完全进入状态，却是很难在这么短的时间实现的。所谓完全进入状态，举个例子：你看了3个小时的书，或者调试了半个小时的程序之后，往往满脑子都是相关的东西，所有这些知识都处在活跃状态，换言之你大脑中所有相关的记忆神经网络都被激活了，要达到这样一种忘记时间流逝的“沉浸”状态（心理学上叫做“流体验”），不是三两分钟的事情。而一旦这种状态被破坏，无形间效率就会大打折扣。这也是为什么我总是倾向于创造大块的时间来阅读重要的东西，因为这样有利于“沉浸”进去，使得新知识可以和大脑中与其相关的各种既有的知识充分融合，关联起来，后者对于深刻的记忆非常有帮助。</p><p>要充分利用暗时间，不仅要能够迅速进入状态，另一个很重要的习惯就是能够保持状态多久（思维体力）。《The Psychology of Invention in the Mathematical Field》上有一段关于庞加莱的思考习惯的介绍，很有代表性。庞加莱经常在去海边休假或者在路上走的时候在脑海中思索数学问题，很多时候解答就在这些时候忽然闪现。虽然我和庞加莱是没法比的，但是常常也在路上想出答案，这真是一种愉悦的体验。</p><p>能够迅速进入专注状态，以及能够长期保持专注状态，是高效学习的两个最重要习惯。</p><p>很多人都有这样的体验（包括我自己），工作了之后，要处理的事情一下多出了很多，不像在校园，环境简单，生活单纯，能够心无旁骛地做一件事情而不被打扰。工作之后的状况就是，首先需要处理的事情变多，导致时不时需要在多个任务之间切换；另一方面，即便能够把任务的优先级分配得比较合理，也难免在做一件事情的时候心中忽然想起另一件事还没做的焦虑来，因为没做完的事情会在大脑中留下一个“隐藏的进程”，时不时地发个消息提醒你一下，中断你正在做的事情。</p><p>因此这里就涉及到最后一个高效的习惯：抗干扰。只有具备超强的抗干扰能力，才能有效地利用起前面提到的种种暗时间。抗干扰能力也是可以练习出来的，上本科那会经常坐车，所以我就常常拿着本大部头在车上看，坐着看或者站着看都可，事实证明在有干扰的环境中看书是非常锻炼专注能力的一个办法:D 另外，经常利用各种碎片时间阅读和思考，对迅速集中注意力和保持注意力都非常有帮助。记得很久以前TopLanguage上大伙曾经有次饶有兴趣地讨论“马桶时间”的利用，包括在卫生间放个小书柜。（估计很多同学心有戚戚焉吧:D）</p><blockquote><pre><code>——刘未鹏 | Mind Hacks</code></pre><p>原文地址：<a href="http://mindhacks.cn/2009/12/20/dark-time/" target="_blank" rel="noopener">http://mindhacks.cn/2009/12/20/dark-time/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你有一台计算机，你装了一个系统之后就整天把它搁置在那里，你觉得这台计算机被实际使用了吗？没有。因为CPU整天运行的就是空闲进程。运行空闲进程也是一天，运行大数据量计算的程序也是一天，对于CPU来说同样的一天，价值却是完全不一样的。&lt;/p&gt;
&lt;p&gt;大脑也是如此。&lt;/p&gt;
    
    </summary>
    
    
      <category term="时间管理" scheme="http://lwju.xyz/categories/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="时间管理" scheme="http://lwju.xyz/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="http://lwju.xyz/Markdown/Markdown/"/>
    <id>http://lwju.xyz/Markdown/Markdown/</id>
    <published>2019-06-09T02:18:01.000Z</published>
    <updated>2019-11-11T09:13:54.272Z</updated>
    
    <content type="html"><![CDATA[<ul><li>代码块高亮</li><li>图片链接和图片上传</li><li>LaTex数学公式</li><li>表格和流程图</li><li>离线写博客</li><li>丰富的快捷键<a id="more"></a></li></ul><hr><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li>加粗<code>Ctrl + B</code></li><li>斜体 <code>Ctrl + I</code></li><li>引用 <code>Ctrl + Q</code></li><li>插入链接 <code>Ctrl + L</code></li><li>插入代码 <code>Ctrl + K</code></li><li>插入图片 <code>Ctrl + G</code></li><li>提升标题 <code>Ctrl + H</code></li><li>有序列表 <code>Ctrl + O</code></li><li>无序列表 <code>Ctrl + U</code></li><li>横线 <code>Ctrl + R</code></li><li>撤销 <code>Ctrl + Z</code></li><li>重做 <code>Ctrl + Y</code></li></ul><hr><h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h4><blockquote><p>创建标题只需在文本前添加#。#的个数代表标题的级数。（还可以通过文本底下加- - -或===实现） </p></blockquote><h4 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h4><h5 id="创建无序列表只需在文本前加上-、-或-；有序列表可以直接在文本前加1-、2-、3-等。-列表也可以嵌套的"><a href="#创建无序列表只需在文本前加上-、-或-；有序列表可以直接在文本前加1-、2-、3-等。-列表也可以嵌套的" class="headerlink" title="创建无序列表只需在文本前加上-、+或 *；有序列表可以直接在文本前加1.、2.、3.等。(列表也可以嵌套的)"></a>创建无序列表只需在文本前加上-、+或 *；有序列表可以直接在文本前加1.、2.、3.等。(列表也可以嵌套的)</h5><blockquote><ul><li>项目</li><li>项目<ul><li>项目</li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol></blockquote><h5 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h5><blockquote><dl><dt>Markdown<br>:  Text-to-HTML conversion tool<br>Authors<br>:  John</dt><dd>Luke</dd></dl></blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input checked="" disabled="" type="checkbox"> 完成任务</li></ul></blockquote><blockquote><p>注意：符号和文本之间需要有空格，前面要有空行。 </p></blockquote><h4 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h4><blockquote><p>引用他人材料时，只需在开头加&gt;(可嵌套使用)。可以通过添加空行来结束引用。 </p></blockquote><h4 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h4><blockquote><p>通过连续输入至少三个*实现，行内不能有其他东西。 </p></blockquote><h4 id="5-目录"><a href="#5-目录" class="headerlink" title="5.目录"></a>5.目录</h4><blockquote><p>在合适的地方输入[toc],便会根据标题自动生成可跳转的目录(注意：前面需要有空行)。 </p></blockquote><h4 id="6-脚注"><a href="#6-脚注" class="headerlink" title="6.脚注"></a>6.脚注</h4><blockquote><p>定义：一个具有注脚的文本。[^2]<br>使用：[^2]: 注脚的解释<br>效果：<br>一个具有注脚的文本。[^2]<br>[^2]: 注脚的解释</p></blockquote><h4 id="7-笔记本和标签"><a href="#7-笔记本和标签" class="headerlink" title="7.笔记本和标签"></a>7.笔记本和标签</h4><blockquote><p>语法为@(笔记本)[标签A|标签B],可以添加笔记本和与标签。 绑定印象笔记（Evernote）账号后，能够同步文章到印象笔记相应笔记本目录下。 </p></blockquote><h4 id="8-改变文本的样式、斜体、粗体与删除线"><a href="#8-改变文本的样式、斜体、粗体与删除线" class="headerlink" title="8.改变文本的样式、斜体、粗体与删除线"></a>8.改变文本的样式、斜体、粗体与删除线</h4><p>粗体（快捷键Ctrl+B）、斜体（快捷键Ctrl+I）及 删除线 的语法如下。</p><blockquote><p>*斜体*<br>*<em>粗体**<br>*<strong>加粗的斜体*</strong><br>*强调文本</em> <em>强调文本</em><br>*<em>加粗文本*</em> <strong>加粗文本</strong><br>==标记文本==<br><del>\</del>删除文本<del>~<br>H</del>2~O is是液体。<br>2^10^ 运算结果是 1024.</p><ul><li>文本注释也是必不可少的<br>Markdown将文本转换为 HTML。</li></ul><p>*[HTML]:   超文本标记语言</p></blockquote><h4 id="9-图片与链接"><a href="#9-图片与链接" class="headerlink" title="9.图片与链接"></a>9.图片与链接</h4><ul><li>图片插入快捷键Ctrl+G,将出现以下对话框，直接复制或插入。</li><li>链接插入快捷键Ctrl+L,将出现以下对话框，输入链接。</li><li>图片和链接语法如下,可以手动输入。<blockquote><p>1.! [name] (URL) ：<strong>示列</strong>:！[图片](./xxx.png )<br>![Alt](<a href="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg" target="_blank" rel="noopener">https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg</a>)<br>2.[链接](<a href="http://www.lwju.xyz)**示列**：[小文博客]" target="_blank" rel="noopener">http://www.lwju.xyz)**示列**：[小文博客]</a>(<a href="http://www.lwju.xyz" target="_blank" rel="noopener">http://www.lwju.xyz</a> )<br>3.链接: [link](<a href="http://www.lwju.xyz" target="_blank" rel="noopener">http://www.lwju.xyz</a>). <strong>示列</strong>：链接: <a href="http://www.lwju.xyz" target="_blank" rel="noopener">小文博客</a>.<br>图片与链接的格式相似，相差一个！。</p></blockquote></li></ul><h4 id="10-设定居中、居左、居右-、字体、字号与颜色"><a href="#10-设定居中、居左、居右-、字体、字号与颜色" class="headerlink" title="10. 设定居中、居左、居右 、字体、字号与颜色"></a>10. 设定居中、居左、居右 、字体、字号与颜色</h4><p>在原生减价中对齐文本是不可能的。不过，您可以使用内嵌HTML标签对齐文本。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;div align = "center"&gt;居中&lt;/div&gt;</span><br><span class="line">&gt;&lt;div style="text-align: center"&gt; 居中 &lt;/div&gt;</span><br><span class="line">&gt;&lt;div style="text-align: right"&gt; 右对齐 &lt;/div&gt;</span><br><span class="line">&gt;&lt;div style="text-align: left"&gt; 左对齐 &lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！</li><li>对，就是内嵌HTML，接下来要讲的功能就需要使用内嵌HTML的方法来实现。</li><li>字体，字号和颜色编辑如下代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;</span><br><span class="line">&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;</span><br><span class="line">&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;</span><br><span class="line">&gt;&lt;font color=#0099ff size=7 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt;</span><br><span class="line">&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;</span><br><span class="line">&gt;&lt;font color=red size=72&gt;color=red&lt;/font&gt;</span><br></pre></td></tr></table></figure>Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3</li></ul><h4 id="11-背景色"><a href="#11-背景色" class="headerlink" title="11. 背景色"></a>11. 背景色</h4><blockquote><p>Markdown本身不支持背景色设置，需要采用内置html的方式实现：借助 table, tr, td 等表格标签的 &gt;bgcolor 属性来实现背景色的功能。举例如下：<br><code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色是：orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></p><table><tr><td bgcolor=orange>背景色是：orange</td></tr></table></blockquote><h4 id="12-代码块"><a href="#12-代码块" class="headerlink" title="12.代码块"></a>12.代码块</h4><p>代码块可分为行内代码和区块代码。他们都是通过反引号“ ` ”实现的。行内代码前后只需要一个反引号；区块代码则需要三个反引号。 </p><ul><li>如何插入一段漂亮的代码片<br>下面展示同样高亮的 <code>代码片</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An highlighted block</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure><h4 id="13-转义"><a href="#13-转义" class="headerlink" title="13. 转义"></a>13. 转义</h4><blockquote><p>\ +你要转义的字符<br><code>^@^</code></p></blockquote><h4 id="14-制作待办事宜"><a href="#14-制作待办事宜" class="headerlink" title="14.制作待办事宜"></a>14.制作待办事宜</h4><blockquote><p>- [ ] 未处理<br>- [x]已处理</p></blockquote><h4 id="15-LaTeX数学公式"><a href="#15-LaTeX数学公式" class="headerlink" title="15.LaTeX数学公式"></a>15.LaTeX数学公式</h4><h5 id="标记公式"><a href="#标记公式" class="headerlink" title="标记公式"></a>标记公式</h5><p>LaTeX的数学公式有两种：行内公式和块级公式。行内公式放在文中与其它文字混编，块级公式单独成行。都使用美元符号进行标记显示。</p><blockquote><ul><li>行内公式<br>标记方法：使用一个美元符号包围起来<br>行内公式：$\Gamma(n) = (n-1)!\quad\forall nin\mathbb N$<br>效果：$\Gamma(n) = (n-1)!\quad\forall nin\mathbb N$<br>上标和下标<br>^表示上标，_表示下标。如果上下标的内容多于一个字符，要用{}把这些内容括起来当成一个整体。上下标是可以嵌套的，也可以同时使用。<br>例子：  $x^{y^z}=(1+e^x)^{-2xy^w}$</li></ul></blockquote><h4 id="16-表格"><a href="#16-表格" class="headerlink" title="16.表格"></a>16.表格</h4><blockquote><p>通过管线图的方式实现。示列如下：<br>| \姓名  | 年龄 | 性别  |<br>| :——– | -——-:| :——: |<br>| 王某| 20 | 男  |<br>效果如下：<br>| 姓名  | 年龄 | 性别  |<br>| :——– | ——–:| :——: |<br>| 王某| 20 | 男  |</p></blockquote><blockquote><h5 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h5><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右<br>| 第一列       | 第二列         | 第三列        |<br>|:———–:| ————-:|:————-|<br>| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 | </p></blockquote><h4 id="17-流程图"><a href="#17-流程图" class="headerlink" title="17.流程图"></a>17.流程图</h4><blockquote><p>流程图的代码需要放在一个语法类型为flow的代码块中。具体步骤如下：</p></blockquote><blockquote><p>定义节点：节点类型有start、operation、condition、end等<br>连接节点：使用-&gt;</p></blockquote><h4 id="18-新的甘特图功能，丰富你的文章"><a href="#18-新的甘特图功能，丰富你的文章" class="headerlink" title="18.新的甘特图功能，丰富你的文章"></a>18.新的甘特图功能，丰富你的文章</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section 现有任务</span><br><span class="line">        已完成               :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        进行中               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        计划一               :         des3, after des2, 5d</span><br><span class="line">        计划二               :         des4, after des3, 5d</span><br></pre></td></tr></table></figure><h4 id="19-UML-图表"><a href="#19-UML-图表" class="headerlink" title="19. UML 图表"></a>19. UML 图表</h4><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">Mermaid</a>. 例如下面产生的一个序列图：:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?</span><br><span class="line">李四--&gt;&gt;王五: 你最近怎么样，王五？</span><br><span class="line">李四--x 张三: 我很好，谢谢!</span><br><span class="line">李四-x 王五: 我很好，谢谢!</span><br><span class="line">Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.</span><br><span class="line"></span><br><span class="line">李四--&gt;&gt;张三: 打量着王五...</span><br><span class="line">张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</span><br></pre></td></tr></table></figure><p>这将产生一个流程图。:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;% raw %&#125;菱形&#125;&#123;% endraw %&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure><h4 id="20-FLowchart流程图"><a href="#20-FLowchart流程图" class="headerlink" title="20. FLowchart流程图"></a>20. FLowchart流程图</h4><p>我们依旧会支持flowchart的流程图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchat</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>####21.离线写博客</p><blockquote><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。</p></blockquote><blockquote><p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p></blockquote><blockquote><p>博客发表后，本地缓存将被删除。　</p></blockquote><blockquote><p>用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p></blockquote><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h5 id="Markdowm首行缩进方法"><a href="#Markdowm首行缩进方法" class="headerlink" title="Markdowm首行缩进方法"></a>Markdowm首行缩进方法</h5><p>一个空格大小的表示：&amp; ensp;或&amp; #8194;，此时只要在相应需要缩进的段落前加上 4个 如上的标记即可，注意要带上分号。<br>两个空格的大小表示：&amp; emsp;或&amp; #8195;，同理，使用2个即可缩进2个汉字，推荐使用该方式。<br>不换行空格：&amp; bsp;或&#160;，使用4个&amp; #160;即可。</p><h5 id="HTML中的实体空格"><a href="#HTML中的实体空格" class="headerlink" title="HTML中的实体空格"></a>HTML中的实体空格</h5><p>  HTML提供了5种空格实体（space entity），它们拥有不同的宽度，非断行空格（&amp; nbsp;）是常规空格的宽度，可运行于所有主流浏览器。其他几种空格（&amp; ensp; &amp; emsp; &amp; thinsp; &amp; zwnj; &amp; zwj;）在不同浏览器中宽度各异。</p><ul><li><p>&amp; nbsp;</p><blockquote><p>它叫不换行空格，全称是 No-Break Space，它是最常见和我们使用最多的空格，大多数的人可能只接触了&nbsp;，它是按下space键产生的空格。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个）。要使用html实体表示才可累加，该空格占据宽度受字体影响明显而强烈。</p></blockquote></li><li><p>&amp; ensp;</p></li></ul><blockquote><p>它叫“半角空格”，全称是 En Space，en是字体排印学的计量单位，为em宽度的一半。段落前空格根据定义，它等同于字体度的一半（如16px字体中就是8px）。名义上是小写字母n的宽度。此空格传承空格家族一贯的特性：透明的，此空格有个相当稳健的特性，就是其占据的宽度正好是1/2个中文宽度，而且基本上不受字体影响。</p></blockquote><ul><li>&amp; emsp;</li></ul><blockquote><p>它叫“全角空格”，全称是 Em Space，em是字体排印学的计量单位，相当于当前指定的点数。例如，1 em在16px的字体中就是16px。此空格也传承空格家族一贯的特性：透明的，此空格也有个相当稳健的特性，就是其占据的宽度正好是1个中文宽度，而且基本上不受字体影响。</p></blockquote><ul><li>&amp; thinsp;</li></ul><blockquote><p>它叫“窄空格”，全称是 Thin Space。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是em之六分之一宽。</p></blockquote><ul><li>&amp; zwnj;</li></ul><blockquote><p>它叫零宽不连字，全称是 Zero Width Non Joiner，简称“ZWNJ”，是一个不打印字符，放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制。Unicode中的零宽不连字字符映射为“”（zero width non-joiner，U+200C），HTML字符值引用为： “‌”</p></blockquote><ul><li>&amp; zwj;</li></ul><blockquote><p>它叫零宽连字，全称是 Zero Width Joiner，简称“ZWJ”，是一个不打印字符，放在某些需要复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果。零宽连字符的Unicode码位是U+200D (HTML: ‍ ‍）。<br>4. 锚点<br>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。</p></blockquote><p>注意： </p><ol><li>Markdown Extra 只支持在标题后插入锚点，其它地方无效。 </li><li>Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</li></ol><p>语法描述：<br>在你准备跳转到的指定标题后插入锚点{#标记}，然后在文档的其它地方写上连接到锚点的链接。</p><p>代码：跳转到<a href="#index">标题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;代码块高亮&lt;/li&gt;
&lt;li&gt;图片链接和图片上传&lt;/li&gt;
&lt;li&gt;LaTex数学公式&lt;/li&gt;
&lt;li&gt;表格和流程图&lt;/li&gt;
&lt;li&gt;离线写博客&lt;/li&gt;
&lt;li&gt;丰富的快捷键
    
    </summary>
    
    
      <category term="Markdown" scheme="http://lwju.xyz/categories/Markdown/"/>
    
    
  </entry>
  
</feed>
